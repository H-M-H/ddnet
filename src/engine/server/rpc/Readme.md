# RPC

## Overview
DDNet-Servers are able to use googles [grpc](https://grpc.github.io/) protocol via protobuf3 to communicate with a service that provides an interface to a database.
The motivation is to provide flexibility regarding the databasebackend and permit pretty much any database for storing and accessing ranks and saves.
Additionally the output of commands like /top5 is easier to customize like this.

A possible setup is:

DDNet-Server <-- grpc --> python-script <-- sqlalchemy --> Postgres/MariaDB/sqlite3...

## Details

### Codegeneration
Code for a databaseclient is autogenerated from the two files: `database_client.cpp.inja` and `database_client.h.inja`.
The tool used for generating it is located in src/tools/rpc and uses the [protobuf-pluginsystem](https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.compiler.plugin.html).
It is automatically build and invoked on compilation, see the section `RPCCODE GENERATION` in `CMakeLists.txt`

### Databaseclient
The class CDatabaseClient provides all RPC-methods defined in `database.proto`.
These are threadsafe, using the queue defined in `src/base/tl/queue.h`, and return a wrapper `CFuture` with a simpler API around a `std::shared_future`.
The Databaseclient is responsible for safely delivering messages, handling timeouts and if everything goes wrong, writing unsent messages to the file defined by `sv_rpc_failure_file`.
As not every message absolutely has to be delivered there is a timeoutoption for RPC-Calls which if not negative permits discarding messages and never writes them to a file.
