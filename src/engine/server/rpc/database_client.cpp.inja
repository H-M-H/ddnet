#include <fstream>
#include <google/protobuf/util/delimited_message_util.h>
#include <base/system.h>
#include <engine/shared/config.h>

#include "database_client.h"

using namespace db;

DatabaseException::DatabaseException(const char* pStr, const grpc::Status St) : m_What(pStr), m_Status(St) {}
DatabaseException::DatabaseException(std::string Str, const grpc::Status St) : m_What(Str), m_Status(St) {}
const grpc::Status& DatabaseException::Status() { return m_Status; }

const char* DatabaseException::what() const noexcept { return m_What.c_str(); }

CDatabaseClient::CDatabaseClient(const char* pAddr, int NumThreads) :
	m_Run(true),
	m_Channel(grpc::CreateChannel(pAddr, grpc::InsecureChannelCredentials())),
## for s, ms in Services
	m_{{s}}Service({{s}}::NewStub(m_Channel)),
## endfor
	m_RPCThreads()
{
	for (int i = 0; i < NumThreads; ++i)
		m_RPCThreads.emplace_back(&CDatabaseClient::Run, this);

}

void CDatabaseClient::Run()
{
	while (m_Run)
	{
		std::function<bool()> Func;
		m_CallQueue.Consume([&Func](std::function<bool()>& F) { Func = std::move(F); });
		if (!Func())
			m_CallQueue.Emplace(Func);
	}
}

## for s, ms in Services
## for m, t in ms
CFuture<{{t.Out}}> CDatabaseClient::{{m}}(const std::shared_ptr<{{t.In}}> Msg, int64 TimeoutMilliseconds)
{
	std::shared_ptr<std::promise<{{t.Out}}>> Promise = std::make_shared<std::promise<{{t.Out}}>>();
	int64 Timeout = time_get_microseconds() + TimeoutMilliseconds * 1000;
	m_CallQueue.Emplace([this, Promise, Msg, TimeoutMilliseconds, Timeout]()
		{
			grpc::ClientContext Context;
			{{t.Out}} Out;
			const grpc::Status Status = m_{{s}}Service->{{m}}(&Context, *Msg.get(), &Out);
			if (Status.ok())
				Promise->set_value(std::move(Out));
			else if(m_Run && (TimeoutMilliseconds < 0 || time_get_microseconds() < Timeout) && Status.error_code() == grpc::StatusCode::UNAVAILABLE)
			{
				dbg_msg("rpc", "Failed to process RPC {{m}} (retrying): %s %s", Status.error_message().c_str(), Status.error_details().c_str());
				return false;
			}
			else
			{
				Promise->set_exception(
					std::make_exception_ptr(
						DatabaseException("Failed to process RPC: {{m}}. " + Status.error_message() + " " + Status.error_details(), std::move(Status))
					)
				);
				if (TimeoutMilliseconds < 0)
				{
					std::ofstream File(g_Config.m_SvRPCFailureFile, std::ofstream::app);
					google::protobuf::util::SerializeDelimitedToOstream(*Msg.get(), &File);
				}
			}
			return true;
		}
	);
	return CFuture<{{t.Out}}>(Promise->get_future());
}
## endfor
## endfor


CDatabaseClient::~CDatabaseClient()
{
	m_Run = false;
	for (size_t i = 0; i < m_RPCThreads.size(); ++i)
		m_CallQueue.Emplace([]() {return true;});
	for (std::thread& Thread : m_RPCThreads)
		Thread.join();
}

